# report

## Ackermann 函數

## 1.遞迴

### 解題說明

Ackermann 函數是一個典型的遞迴函數，其數學定義如下：
		 1.​ n+1				m=0
A(m,n)=  2. A(m−1,1)		m>0,n=0
		 3. A(m-1,A(m,n-1))	m>0,n>0
		 
#### 問題描述

本題要求計算 Ackermann 函數 A(m, n) 的值。Ackermann 函數是一個經典的遞迴函數，定義如下：
若 m = 0，則回傳 n + 1。
若 n = 0，則回傳 A(m - 1, 1)。
否則回傳 A(m - 1, A(m, n - 1))。

#### 解題策略

利用遞迴方式直接依據定義實作函數 ack(m, n)。
主程式讀入兩個整數 m、n，呼叫 ack(m, n) 計算並輸出結果。
由於 Ackermann 函數的遞迴深度非常大，只適合處理小的輸入值，以避免堆疊溢位。

### 程式實作

以下為主要程式碼：

```cpp
#include <iostream>
using namespace std;

int ack(int m, int n) {
    if (m == 0) return n + 1;
    if (n == 0) return ack(m - 1, 1);
    return ack(m - 1, ack(m, n - 1));
}

int main() {
    int m, n;
    cin >> m >> n;
    cout << ack(m, n) << endl;
    return 0;
}
```

### 效能分析

1.時間複雜度：
Ackermann 函數是一個極度遞迴的函數，其時間複雜度隨 m、n 增長極快。
對小 m（例如 m=0、1、2）可以近似用 O(n) 或 O(2^n) 表示。
對一般 m、n，時間複雜度大約 O(A(m, n))，因為函數本身的遞迴深度與呼叫次數會呈現 超指數增長。
總結：時間複雜度非常高，對大輸入幾乎不可行。

2.空間複雜度：
由於使用純遞迴，每次函數呼叫都會佔用堆疊空間，堆疊深度等於遞迴層數。
空間複雜度大約與時間複雜度同階：O(A(m, n))。
對小輸入可以忽略，但輸入稍大就可能導致 stack overflow。

### 測試與驗證

#### 測試案例

| 測試案例 | 輸入參數 m | 輸入參數 n | 預期輸出 | 實際輸出 |
|-----------|------------|------------|-----------|-----------|
| 測試一   | 0          | 0          | 1         | 1         |
| 測試二   | 1          | 3          | 5         | 5         |
| 測試三   | 2          | 3          | 9         | 9         |
| 測試四   | 3          | 4          | 125       | 125       |
| 測試五   | 4          | 1          | 65533     | 異常拋出 (stack overflow) |

> **備註**：Ackermann 函數對 m ≥ 4 時，容易造成堆疊溢位（stack overflow），因此實際執行可能拋出異常。

#### 編譯與執行指令

```shell
$ g++ ack.cpp -std=c++14 -o ack (Visual Studio 2022 為C+14)
$ ack.exe
A(m,n)
輸入 m 值:
(輸入)2
輸入 n 值:
(輸入)3
(結果): 9
```

### 申論及開發報告

#### 選擇遞迴的原因

在本程式中，使用遞迴來計算 Ackermann 函數的主要原因如下：

1. 程式邏輯簡單直觀
   遞迴能清楚表達「將問題拆解為更小的子問題」的概念，直到 m 或 n 達到基準條件返回結果。

2. 易於理解與實現  
   遞迴程式碼接近數學公式表示方式，直觀且適合展示遞迴基本概念。

3. 遞迴語意清楚  
   每次呼叫代表一個子問題的解，最終結果逐層返回，完成整體問題求解，無需額外變數維護中間狀態。  
#### 改進方式

為了避免遞迴造成 Stack Overflow ，可考慮：
- 使用 迭代（Iteration) 或 尾遞迴（Tail Recursion） 優化。  
- 對較大輸入值採用 記憶化（Memoization) 或 動態規劃（Dynamic Programming） 儲存中間結果，減少重複計算。

---------

## 2.非遞迴

### 解題說明

Ackermann 函數是一個典型的遞迴函數，其數學定義如下：
		 1.​ n+1				m=0
A(m,n)=  2. A(m−1,1)		m>0,n=0
		 3. A(m-1,A(m,n-1))	m>0,n>0
		 
#### 問題描述
計算 Ackermann 函數 A(m,n) 的值。因傳統遞迴可能造成 Stack Overflow，本程式改用非遞迴方式計算。

#### 解題策略
使用 陣列模擬堆疊，存放待計算的 m 值，迴圈模擬遞迴呼叫。
根據 Ackermann 函數定義處理每個 m 與 n 的情況，更新 n 或將新的子問題壓入堆疊。
迴圈結束後，返回最終 n 作為結果，避免遞迴造成的堆疊溢位，同時保持程式邏輯與數學公式一致。

### 程式實作

以下為主要程式碼：

```cpp
#include <iostream>
using namespace std;

int ack(int m, int n) {
    const int MAX = 10000;
    int M[MAX];
    int top = 0;
    M[top++] = m;

    while (top > 0) {
        m = M[--top];

        if (m == 0)  n += 1;
        else if (n == 0) {
            M[top++] = m - 1;
            n = 1;
        }
        else {
            M[top++] = m - 1;
            M[top++] = m;
            n -= 1;
        }
    }
    return n;
}
int main() {
    int m, n;
    cin >> m >> n;
    cout << ack(m, n) << endl;
    return 0;
}
```

### 效能分析

1.時間複雜度：
Ackermann 函數本身是一個超指數成長的函數，遞迴層數極深，即使改用迭代方式，計算步數仍非常多。
對程式而言，每次迴圈會處理堆疊中的一個 m 值，並可能壓入多個新的 m 值。
因此時間複雜度與 Ackermann 函數的值同階，大約為 O(A(m, n))。
對小輸入，例如 m ≤ 3，時間複雜度可粗略視為 O(2^n) 或 O(多重指數)，但對大 m、n，增長極快。

2.空間複雜度：
程式使用陣列 M[MAX] 模擬堆疊，空間需求取決於堆疊最多同時存放的 m 值數量。
因每個 m 可能產生多個子問題，堆疊深度近似 Ackermann 函數的遞迴深度。
空間複雜度大約為 O(A(m, n))。
優點是使用迭代避免了系統呼叫堆疊溢位，但仍受陣列大小限制（MAX = 10000）。

### 測試與驗證

#### 測試案例

| 測試案例 | 輸入參數 m | 輸入參數 n | 預期輸出 | 實際輸出 |
|-----------|------------|------------|-----------|-----------|
| 測試一   | 0          | 0          | 1         | 1         |
| 測試二   | 1          | 3          | 5         | 5         |
| 測試三   | 2          | 3          | 9         | 9         |
| 測試四   | 3          | 4          | 125       | 125       |
| 測試五   | 4          | 1          | 65533     | 異常拋出 (stack overflow) |

> **備註**：Ackermann 函數對 m ≥ 4 時，容易造成堆疊溢位（stack overflow），因此實際執行可能拋出異常。

#### 編譯與執行指令

```shell
A(m,n)
輸入 m 值: 2
輸入 n 值: 3
結果: 9
```

### 申論及開發報告

#### 選擇非遞迴的原因

在本程式中，使用非遞迴方式來計算 Ackermann 函數的主要原因如下：

1. **避免遞迴堆疊溢位**  
   使用陣列模擬堆疊取代系統呼叫堆疊，可處理比傳統遞迴更大的輸入值，降低 Stack Overflow 風險。

2. **程式邏輯清楚**  
   透過迴圈與自訂堆疊，清楚表達「將問題拆解為子問題」的邏輯，每次迴圈處理堆疊頂端的 m 值並更新 n。

3. **易於理解與維護**  
   迭代程式碼接近數學公式，且不需要額外變數來追蹤遞迴呼叫，方便檢查和維護程式。

#### 改進方式

雖然非遞迴版本避免了系統堆疊溢位，但對大輸入值仍可能遇到陣列大小限制或超長運算時間，可考慮以下改進：

- **動態調整堆疊大小**，避免固定陣列上限限制。  
- **記憶化（Memoization）** 或 **動態規劃（Dynamic Programming）** 儲存中間結果，減少重複計算。  
- 針對非常大輸入，可結合 **尾遞迴優化** 或其他數學化簡公式，提升效率。
